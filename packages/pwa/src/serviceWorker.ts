/**
 * @fileoverview Service worker utilities
 *
 * Utilities for creating and registering service workers.
 */

/**
 * Options for service worker registration
 */
export interface ServiceWorkerOptions {
    /**
     * Service worker script path
     */
    scriptPath?: string;

    /**
     * Service worker scope
     */
    scope?: string;

    /**
     * Whether to register the service worker immediately
     */
    immediate?: boolean;

    /**
     * Callback for successful registration
     */
    onSuccess?: (registration: ServiceWorkerRegistration) => void;

    /**
     * Callback for registration error
     */
    onError?: (error: Error) => void;

    /**
     * Callback for when the service worker is ready
     */
    onReady?: (registration: ServiceWorkerRegistration) => void;
}

/**
 * Registers a service worker
 *
 * @param options Service worker options
 * @returns Promise that resolves to the service worker registration
 *
 * @example
 * ```typescript
 * registerServiceWorker({
 *   scriptPath: '/sw.js',
 *   onSuccess: (registration) => {
 *     console.log('Service worker registration successful', registration);
 *   },
 *   onError: (error) => {
 *     console.error('Service worker registration failed', error);
 *   }
 * });
 * ```
 */
export function registerServiceWorker(options: ServiceWorkerOptions = {}): Promise<ServiceWorkerRegistration | undefined> {
    const {
        scriptPath = '/sw.js',
        scope = '/',
        immediate = true,
        onSuccess,
        onError,
        onReady
    } = options;

    // Check if service workers are supported
    if (typeof navigator === 'undefined' || !('serviceWorker' in navigator)) {
        const error = new Error('Service workers are not supported in this browser');

        if (onError) {
            onError(error);
        }

        return Promise.reject(error);
    }

    // Register the service worker
    const register = () => {
        return navigator.serviceWorker
            .register(scriptPath, { scope })
            .then(registration => {
                if (onSuccess) {
                    onSuccess(registration);
                }

                // Handle updates
                registration.onupdatefound = () => {
                    const installingWorker = registration.installing;

                    if (installingWorker) {
                        installingWorker.onstatechange = () => {
                            if (installingWorker.state === 'activated' && onReady) {
                                onReady(registration);
                            }
                        };
                    }
                };

                return registration;
            })
            .catch(error => {
                if (onError) {
                    onError(error);
                }

                throw error;
            });
    };

    // Register immediately or wait for load event
    if (immediate) {
        return register();
    } else {
        if (typeof window !== 'undefined') {
            return new Promise((resolve, reject) => {
                window.addEventListener('load', () => {
                    register().then(resolve).catch(reject);
                });
            });
        }

        return Promise.resolve(undefined);
    }
}

/**
 * Checks if the app is running in standalone mode
 *
 * @returns Whether the app is in standalone mode
 */
export function isStandalone(): boolean {
    if (typeof window === 'undefined') {
        return false;
    }

    return (
        window.matchMedia('(display-mode: standalone)').matches ||
        (window.navigator as any).standalone === true
    );
}

/**
 * Generates a basic service worker script
 *
 * @param options Service worker generation options
 * @returns Service worker script as a string
 */
export function generateServiceWorker(options: {
    cacheName?: string;
    version?: string;
    filesToCache?: string[];
    offlinePage?: string;
} = {}): string {
    const {
        cacheName = 'rytestack-cache',
        version = '1',
        filesToCache = [],
        offlinePage = '/offline.html'
    } = options;

    return `
    // Service worker generated by Rytestack
    const CACHE_NAME = '${cacheName}-v${version}';
    const OFFLINE_PAGE = '${offlinePage}';
    
    const ASSETS_TO_CACHE = [
      '/',
      OFFLINE_PAGE,
      ${filesToCache.map(file => `'${file}'`).join(',\n      ')}
    ];
    
    // Install event - cache assets
    self.addEventListener('install', (event) => {
      event.waitUntil(
        caches.open(CACHE_NAME)
          .then((cache) => cache.addAll(ASSETS_TO_CACHE))
          .then(() => self.skipWaiting())
      );
    });
    
    // Activate event - clean old caches
    self.addEventListener('activate', (event) => {
      event.waitUntil(
        caches.keys()
          .then((cacheNames) => {
            return Promise.all(
              cacheNames
                .filter((name) => name.startsWith('${cacheName}-') && name !== CACHE_NAME)
                .map((name) => caches.delete(name))
            );
          })
          .then(() => self.clients.claim())
      );
    });
    
    // Fetch event - respond with cache or fetch
    self.addEventListener('fetch', (event) => {
      // Skip non-GET requests
      if (event.request.method !== 'GET') {
        return;
      }
      
      // Skip cross-origin requests
      if (!event.request.url.startsWith(self.location.origin)) {
        return;
      }
      
      event.respondWith(
        caches.match(event.request)
          .then((cachedResponse) => {
            // Return cached response if available
            if (cachedResponse) {
              return cachedResponse;
            }
            
            // Otherwise, fetch from network
            return fetch(event.request)
              .then((response) => {
                // Return the response
                return response;
              })
              .catch(() => {
                // If fetch fails (offline), show offline page
                return caches.match(OFFLINE_PAGE);
              });
          })
      );
    });
  `;
}